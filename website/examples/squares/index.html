---
layout: default
title: "Stardust Example: Squares"
---
<h1>Stardust Example: Squares</h1>
<iframe class="example-container" src="content.html" width="960px" height="500px" scrolling="no" sandbox="allow-popups allow-scripts allow-forms allow-same-origin"></iframe>
<p>The Squares performance visualization for multiclass classifiers, implemented using <a href="https://stardustjs.github.io/">Stardust</a>.</p>
<p>Data shown here is a 10-class classifier trained on the MNIST dataset.</p>

<h2>index.html</h2>
<pre><code class="highlight html">&lt;!DOCTYPE html&gt;
&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;
&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;common&#x2F;style.css&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt;
&lt;script src&#x3D;&quot;&#x2F;&#x2F;d3js.org&#x2F;d3.v3.min.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;
&lt;script src&#x3D;&quot;..&#x2F;common&#x2F;stardust&#x2F;stardust.bundle.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;
&lt;script src&#x3D;&quot;..&#x2F;common&#x2F;utils.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;
&lt;style&gt;
    .squares-container {
        position: relative;
    }
    .squares-container canvas, .squares-container svg {
        position: absolute;
        left: 0; top: 0;
    }
    .squares-container svg {
        pointer-events: none;
    }
    .axis path,
    .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
    }

    .axis text {
        font-family: sans-serif;
        font-size: 11px;
    }
&lt;&#x2F;style&gt;
&lt;div class&#x3D;&quot;squares-container&quot;&gt;
    &lt;canvas id&#x3D;&quot;main-canvas&quot;&gt;&lt;&#x2F;canvas&gt;
    &lt;svg id&#x3D;&quot;main-svg&quot;&gt;&lt;&#x2F;svg&gt;
&lt;&#x2F;div&gt;
&lt;div class&#x3D;&quot;initializing&quot;&gt;&lt;p&gt;Initializing...&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;
&lt;script src&#x3D;&quot;squares.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;
&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;
    var container &#x3D; d3.select(&quot;.squares-container&quot;);
    var vis &#x3D; new SquaresVisualization(container.node());
    loadData(&quot;mnist.csv&quot;, (DATA) &#x3D;&gt; {
        vis.layout();
        vis.setInstances(DATA.slice(0, 4000));
        vis.setLayoutParameter({
            y0: 10,
            numberBins: 10,
            squaresPerBin: 11,
            squareSize: 3,
            squareSpacing: 4,
            xSpacing: 88
        });
    });
&lt;&#x2F;script&gt;</code></pre>
<h2>squares.js</h2>
<pre><code class="highlight javascript">class SquaresVisualization {

    makeSquaresMark(side, mode) {
        let squares &#x3D; Stardust.mark.custom()
            .input(&quot;size&quot;, &quot;float&quot;)
            .input(&quot;spacing&quot;, &quot;float&quot;)
            .input(&quot;x0&quot;, &quot;float&quot;)
            .input(&quot;xSpacing&quot;, &quot;float&quot;)
            .input(&quot;y1&quot;, &quot;float&quot;)
            .input(&quot;binSpacing&quot;, &quot;float&quot;)
            .input(&quot;binIndex&quot;, &quot;float&quot;)
            .input(&quot;binSquares&quot;, &quot;float&quot;)
            .input(&quot;bin&quot;, &quot;float&quot;)
            .input(&quot;color&quot;, &quot;Color&quot;);
        if(side &#x3D;&#x3D; &quot;right&quot;) {
            squares
                .input(&quot;assigned&quot;, &quot;float&quot;)
                .variable(&quot;x&quot;, &quot;x0 + xSpacing * assigned&quot;)
        } else {
            squares
                .input(&quot;label&quot;, &quot;float&quot;)
                .variable(&quot;x&quot;, &quot;x0 + xSpacing * label&quot;)
        }
        squares
            .variable(&quot;y&quot;, &quot;y1 - bin * binSpacing&quot;)
            .variable(&quot;binIx&quot;, &quot;floor(binIndex &#x2F; binSquares)&quot;)
            .variable(&quot;binIy&quot;, &quot;(binIndex % binSquares)&quot;)
            .variable(&quot;bx&quot;, &quot;binIx * spacing&quot;)
            .variable(&quot;by&quot;, &quot;binIy * spacing&quot;)
        if(side &#x3D;&#x3D; &quot;right&quot;) {
            squares
                .variable(&quot;px&quot;, &quot;x + bx&quot;)
                .variable(&quot;py&quot;, &quot;y + by&quot;);
        } else {
            squares
                .variable(&quot;px&quot;, &quot;x - bx - spacing&quot;)
                .variable(&quot;py&quot;, &quot;y + by&quot;);
        }
        if(mode &#x3D;&#x3D; &quot;solid&quot;) {
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px, py)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + spacing, py + spacing)&quot;)
                    .attr(&quot;color&quot;, &quot;Color(1, 1, 1, 1)&quot;);
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px, py)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + size, py + size)&quot;)
                    .attr(&quot;color&quot;, &quot;color&quot;);
        }
        if(mode &#x3D;&#x3D; &quot;outlined&quot;) {
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px, py)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + spacing, py + spacing)&quot;)
                    .attr(&quot;color&quot;, &quot;Color(1, 1, 1, 1)&quot;);
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px, py)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + size, py + size)&quot;)
                    .attr(&quot;color&quot;, &quot;color&quot;);
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px + 0.5, py + 0.5)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + size - 0.5, py + size - 0.5)&quot;)
                    .attr(&quot;color&quot;, &quot;Color(1, 1, 1, 1)&quot;);
        }
        if(mode &#x3D;&#x3D; &quot;selection&quot;) {
            squares
                .add(&quot;P2D.Rectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px, py)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + size, py + size)&quot;)
                    .attr(&quot;color&quot;, &quot;Color(0, 0, 0, 0)&quot;);
            squares
                .add(&quot;P2D.OutlinedRectangle&quot;)
                    .attr(&quot;p1&quot;, &quot;Vector2(px - 0.5, py - 0.5)&quot;)
                    .attr(&quot;p2&quot;, &quot;Vector2(px + size + 0.5, py + size + 0.5)&quot;)
                    .attr(&quot;color&quot;, &quot;Color(0, 0, 0, 1)&quot;);
        }
        return squares;
    }

    constructor(container) {
        let squares &#x3D; this.makeSquaresMark(&quot;right&quot;, &quot;solid&quot;);
        let squaresOutlined &#x3D; this.makeSquaresMark(&quot;left&quot;, &quot;outlined&quot;);
        let squaresSelection &#x3D; this.makeSquaresMark(&quot;right&quot;, &quot;selection&quot;);
        let squaresOutlinedSelection &#x3D; this.makeSquaresMark(&quot;left&quot;, &quot;selection&quot;);

        let parallelCoordinates &#x3D; Stardust.mark.custom()
            .input(&quot;color&quot;, &quot;Color&quot;)
            .input(&quot;x0&quot;, &quot;float&quot;)
            .input(&quot;xSpacing&quot;, &quot;float&quot;);
        for(let i &#x3D; 0; i &lt; 10; i++) {
            parallelCoordinates.input(&#x60;y${i}&#x60;, &quot;float&quot;);
            parallelCoordinates.variable(&#x60;x${i}&#x60;, &#x60;x0 + xSpacing * ${i}&#x60;);
            if(i &lt; 9) {
                parallelCoordinates.add(&quot;P2D.Line&quot;)
                    .attr(&quot;p1&quot;, &#x60;Vector2(x${i}, y${i})&#x60;)
                    .attr(&quot;p2&quot;, &#x60;Vector2(x${i + 1}, y${i + 1})&#x60;)
                    .attr(&quot;width&quot;, 2)
                    .attr(&quot;color&quot;, &#x60;Color(color.r, color.g, color.b, 0.3)&#x60;);
            }
        }

        this._container &#x3D; container;
        this._canvas &#x3D; d3.select(container).append(&quot;canvas&quot;);
        this._canvasNode &#x3D; this._canvas.node();
        this._svg &#x3D; d3.select(container).append(&quot;svg&quot;);
        this._svgAxis &#x3D; this._svg.append(&quot;g&quot;).classed(&quot;axis&quot;, true);

        let platform &#x3D; Stardust.platform(&quot;webgl-2d&quot;, this._canvasNode);

        this._platform &#x3D; platform;

        this._layout &#x3D; {
            numberBins: 10,
            squaresPerBin: 10,
            squareSize: 2,
            squareSpacing: 3,
            x0: 80,
            xSpacing: 100,
            y0: 10,
            numberClasses: 10
        };

        let colors &#x3D; [[31,119,180],[255,127,14],[44,160,44],[214,39,40],[148,103,189],[140,86,75],[227,119,194],[127,127,127],[188,189,34],[23,190,207]];
        colors &#x3D; colors.map((x) &#x3D;&gt; [ x[0] &#x2F; 255, x[1] &#x2F; 255, x[2] &#x2F; 255, 1 ]);

        let mark &#x3D; Stardust.mark.create(squares, platform);
        mark
            .attr(&quot;color&quot;, d &#x3D;&gt; colors[d.label])
            .attr(&quot;assigned&quot;, d &#x3D;&gt; d.assigned)
            .attr(&quot;binIndex&quot;, d &#x3D;&gt; d.binIndex)
            .attr(&quot;bin&quot;, d &#x3D;&gt; d.scoreBin);

        let mark2 &#x3D; Stardust.mark.create(squaresOutlined, platform);
        mark2
            .attr(&quot;color&quot;, d &#x3D;&gt; colors[d.assigned])
            .attr(&quot;label&quot;, d &#x3D;&gt; d.label)
            .attr(&quot;binIndex&quot;, d &#x3D;&gt; d.binIndex2)
            .attr(&quot;bin&quot;, d &#x3D;&gt; d.scoreBin);

        let markOverlay &#x3D; Stardust.mark.create(squaresSelection, platform);
        markOverlay
            .attr(&quot;color&quot;, [ 0, 0, 0, 1 ])
            .attr(&quot;assigned&quot;, d &#x3D;&gt; d.assigned)
            .attr(&quot;binIndex&quot;, d &#x3D;&gt; d.binIndex)
            .attr(&quot;bin&quot;, d &#x3D;&gt; d.scoreBin);

        let markOverlayOutlined &#x3D; Stardust.mark.create(squaresOutlinedSelection, platform);
        markOverlayOutlined
            .attr(&quot;color&quot;, [ 0, 0, 0, 1 ])
            .attr(&quot;label&quot;, d &#x3D;&gt; d.label)
            .attr(&quot;binIndex&quot;, d &#x3D;&gt; d.binIndex2)
            .attr(&quot;bin&quot;, d &#x3D;&gt; d.scoreBin);

        let markPC &#x3D; Stardust.mark.create(parallelCoordinates, platform);
        let yScale &#x3D; Stardust.scale.linear()
            .domain([ 0, 1 ]).range([ 500, 100 ]);
        markPC.attr(&quot;color&quot;, d &#x3D;&gt; colors[d.label]);
        for(let i &#x3D; 0; i &lt; 10; i++) {
            ((i) &#x3D;&gt; {
                markPC.attr(&#x60;y${i}&#x60;, yScale(d &#x3D;&gt; d.scores[i]));
            })(i);
        }

        this._marks &#x3D; {
            squares: mark,
            squaresOutlined: mark2,
            squaresOverlay: markOverlay,
            squaresOverlayOutlined: markOverlayOutlined,
            parallelCoordinates: markPC,
            yScale: yScale
        }



        this._canvasNode.onmousemove &#x3D; e &#x3D;&gt; {
            let bounds &#x3D; this._canvasNode.getBoundingClientRect();
            var x &#x3D; e.clientX - bounds.left;
            var y &#x3D; e.clientY - bounds.top;
            var p &#x3D; this._platform.getPickingPixel(x * 2, y * 2);
            if(p) {
                this.setSelection([ p[0].data()[p[1]] ]);
            } else {
                this.setSelection([]);
            }
        };
        this._canvasNode.onmousedown &#x3D; e &#x3D;&gt; {
            let bounds &#x3D; this._canvasNode.getBoundingClientRect();
            var x &#x3D; e.clientX - bounds.left;
            var y &#x3D; e.clientY - bounds.top;
            var p &#x3D; this._platform.getPickingPixel(x * 2, y * 2);
            if(p) {
                let inst &#x3D; p[0].data()[p[1]];
                let selection &#x3D; this._instances.filter((d) &#x3D;&gt; d.label &#x3D;&#x3D; inst.label &amp;&amp; d.assigned &#x3D;&#x3D; inst.assigned &amp;&amp; d.scoreBin &#x3D;&#x3D; inst.scoreBin);
                this.setSelection(selection);
            } else {
                this.setSelection([]);
            }
        };
        this._canvasNode.ondblclick &#x3D; e &#x3D;&gt; {
            let bounds &#x3D; this._canvasNode.getBoundingClientRect();
            var x &#x3D; e.clientX - bounds.left;
            var y &#x3D; e.clientY - bounds.top;
            var p &#x3D; this._platform.getPickingPixel(x * 2, y * 2);
            if(p) {
                let inst &#x3D; p[0].data()[p[1]];
                let selection &#x3D; this._instances.filter((d) &#x3D;&gt; d.label &#x3D;&#x3D; inst.label &amp;&amp; d.assigned &#x3D;&#x3D; inst.assigned);
                this.setSelection(selection);
            } else {
                this.setSelection([]);
            }
        };
    }

    setSelection(instances) {
        this._marks.squaresOverlay.data(instances);
        this._marks.squaresOverlayOutlined.data(instances.filter(d &#x3D;&gt; d.label !&#x3D; d.assigned));
        this._marks.parallelCoordinates.data(instances);
        this.renderSelection();
    }

    setInstances(DATA) {
        this._DATA &#x3D; DATA;
        this._layout.numberClasses &#x3D; 10;
        let instances &#x3D; DATA.map((d) &#x3D;&gt; {
            return {
                label: parseInt(d.Label.substr(1)),
                assigned: parseInt(d.Assigned.substr(1)),
                score: d[d.Assigned],
                scoreBin: Math.min(this._layout.numberBins - 1, Math.max(0, Math.floor(parseFloat(d[d.Assigned]) * this._layout.numberBins))),
                scores: [ +d.C0, +d.C1, +d.C2, +d.C3, +d.C4, +d.C5, +d.C6, +d.C7, +d.C8, +d.C9 ]
            };
        });

        let CM &#x3D; [];
        let CMBin &#x3D; [];

        for(let i &#x3D; 0; i &lt; this._layout.numberClasses; i++) {
            CM[i] &#x3D; [];
            CMBin[i] &#x3D; [];
            for(let j &#x3D; 0; j &lt; this._layout.numberClasses; j++) {
                CM[i][j] &#x3D; 0;
                CMBin[i][j] &#x3D; [];
                for(let k &#x3D; 0; k &lt; this._layout.numberBins; k++) {
                    CMBin[i][j][k] &#x3D; 0;
                }
            }
        }

        instances.sort(function(a, b) {
            if(a.label &#x3D;&#x3D; a.assigned) return b.label &#x3D;&#x3D; b.assigned ? 0 : +1;
            if(b.label &#x3D;&#x3D; b.assigned) return a.label &#x3D;&#x3D; a.assigned ? 0 : -1;
            if(a.assigned !&#x3D; b.assigned)
                return a.assigned - b.assigned;
            if(a.label !&#x3D; b.label)
                return a.label - b.label;
            return a.score - b.score;
        })

        instances.forEach(function(d) {
            d.CMIndex &#x3D; CM[d.label][d.assigned];
            CM[d.label][d.assigned] +&#x3D; 1;
            d.binIndex &#x3D; CMBin[0][d.assigned][d.scoreBin];
            CMBin[0][d.assigned][d.scoreBin] +&#x3D; 1;
        });

        instances.sort(function(a, b) {
            if(a.label &#x3D;&#x3D; a.assigned) return b.label &#x3D;&#x3D; b.assigned ? 0 : +1;
            if(b.label &#x3D;&#x3D; b.assigned) return a.label &#x3D;&#x3D; a.assigned ? 0 : -1;
            if(a.assigned !&#x3D; b.assigned)
                return -(a.assigned - b.assigned);
            if(a.label !&#x3D; b.label)
                return a.label - b.label;
            return a.score - b.score;
        })

        instances.forEach(function(d) {
            d.binIndex2 &#x3D; CMBin[1][d.label][d.scoreBin];
            CMBin[1][d.label][d.scoreBin] +&#x3D; 1;
        });

        instances.forEach(function(d) {
            d.CMCount &#x3D; CM[d.label][d.assigned];
        });

        instances.sort(function(a, b) {
            return a.assigned - b.assigned;
        });

        this._instances &#x3D; instances;

        this._marks.squares.data(this._instances);
        this._marks.squaresOutlined.data(this._instances.filter(d &#x3D;&gt; d.label !&#x3D; d.assigned));

        this.layout();
        this.render();
    }

    layoutConfigSquares() {
        let binSpacing &#x3D; this._layout.squareSpacing * this._layout.squaresPerBin + this._layout.squareSpacing;
        this._marks.yScale.range([ this._layout.y0 + binSpacing * this._layout.numberBins, this._layout.y0 ]);

        [
            this._marks.squares,
            this._marks.squaresOutlined,
            this._marks.squaresOverlay,
            this._marks.squaresOverlayOutlined
        ].forEach(s &#x3D;&gt; s
            .attr(&quot;size&quot;, this._layout.squareSize)
            .attr(&quot;spacing&quot;, this._layout.squareSpacing)
            .attr(&quot;x0&quot;, this._layout.x0)
            .attr(&quot;xSpacing&quot;, this._layout.xSpacing)
            .attr(&quot;y1&quot;, this._layout.y0 + binSpacing * this._layout.numberBins - binSpacing + this._layout.squareSpacing &#x2F; 2)
            .attr(&quot;binSpacing&quot;, binSpacing)
            .attr(&quot;binSquares&quot;, this._layout.squaresPerBin)
        );
        this._marks.parallelCoordinates
            .attr(&quot;x0&quot;, this._layout.x0)
            .attr(&quot;xSpacing&quot;, this._layout.xSpacing);
    }
    layout() {
        this.layoutConfigSquares();

        var d3yscale &#x3D; d3.scale.linear().domain(this._marks.yScale.domain()).range(this._marks.yScale.range());
        var axis &#x3D; d3.svg.axis().scale(d3yscale).orient(&quot;left&quot;);
        this._svgAxis.attr(&quot;transform&quot;, &quot;translate(30, 0)&quot;);
        this._svgAxis.call(axis);

        let width &#x3D; 960;
        let height &#x3D; 500;
        this._svg.attr(&quot;width&quot;, width).attr(&quot;height&quot;, height);
        this._platform.resize(width, height);
    }
    render() {
        this._platform.beginPicking(this._canvasNode.width, this._canvasNode.height);
        this._marks.squares.render();
        this._marks.squaresOutlined.render();
        this._platform.endPicking();

        this._platform.clear();
        this._marks.squares.render();
        this._marks.squaresOutlined.render();
    }
    renderSelection() {
        this._platform.clear();
        this._marks.squares.render();
        this._marks.squaresOutlined.render();
        this._marks.squaresOverlay.render();
        this._marks.squaresOverlayOutlined.render();
        this._marks.parallelCoordinates.render();
    }

    setLayoutParameter(layout) {
        let shouldRecompute &#x3D; false;
        for(let p in layout) {
            if(layout.hasOwnProperty(p)) {
                this._layout[p] &#x3D; layout[p];
                if(p &#x3D;&#x3D; &quot;numberBins&quot; || p &#x3D;&#x3D; &quot;numberClasses&quot;) {
                    shouldRecompute &#x3D; true;
                }
            }
        }
        if(shouldRecompute) {
            this.setInstances(this._DATA);
        }
        this.layout();
        this.render();
    }
}
</code></pre>
